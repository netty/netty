<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD; 
]>
<chapter id="start">
  <title>Getting Started</title>
  <para>
    This chapter tours around the core constructs of Netty with simple
    examples to let you get started with Netty easily.  You will be able to
    write a network application on top of Netty right away when you are at the
    end of this chapter.
  </para>
  
  <!-- The chapter 2 is not written yet. -->
  <!--para>
    If you prefer the top-down approach in learning something, you might want
    to start from <xref linkend="architecture"/> and get back here.
  </para-->
  
  <section>
    <title>Before Getting Started</title>
    <para>
      The minimum requirements to run the examples which are introduced in
      this chapter are just two; the latest version of Netty and JDK 1.5 or
      above.  The latest version of Netty is available in
      <ulink url="&Downloads;">the project download page</ulink>.  To get the
      right version of JDK, please refer to your preferred JDK vendor's web
      site.  
    </para>
    <para>
      Is that all?  To tell the truth, you should find these two are just
      enough to implement almost any type of protocols.  Otherwise, please
      feel free to <ulink url="&Community;">contact the Netty
      project community</ulink> and let us know what's missing.
    </para>
    <para>
      At last but least, please refer to the API reference whenever you want
      to know more about the classes introduced here.  All class names in
      this document are linked to the online API reference for your
      convenience.  Also, please don't hesitate to
      <ulink url="&Community;">contact the Netty project community</ulink> and
      let us know if there's any incorrect information, errors in grammar and
      typo, and if you have a good idea to improve the documentation. 
    </para>
  </section>
  
  <section>
    <title>Writing a Discard Server</title>
    <para>
      The most simplistic protocol in the world is not 'Hello, World!' but 
      <ulink url="http://tools.ietf.org/html/rfc863">DISCARD</ulink>.  It's
      a protocol which discards any received data without any response.
    </para>
    <para>
      What you are supposed to do to implement the DISCARD protocol is to log
      the received data, and that's all.  Let's start straight from the handler
      implementation, which handles I/O events generated by Netty.
    </para>
    <programlisting>package org.jboss.netty.example.discard;

@&ChannelPipelineCoverage;("all")<co id="example.discard.co1"/>
public class DiscardServerHandler extends &SimpleChannelHandler; {<co id="example.discard.co2"/>

    @Override
    public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {<co id="example.discard.co3"/>
    }

    @Override
    public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {<co id="example.discard.co4"/>
        e.getCause().printStackTrace();
        
        &Channel; ch = e.getChannel();
        ch.close();
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.discard.co1">
        <para>
          &ChannelPipelineCoverage; annotates a handler type to tell if the
          handler instance of the annotated type can be shared by more than
          one &Channel; (and its associated &ChannelPipeline;).
          <classname>DiscardServerHandler</classname> doesn't manage any
          stateful information, and therefore it's annotated with the value
          <literal>"all"</literal>.
        </para>
      </callout>
      <callout arearefs="example.discard.co2">
        <para>
          <classname>DiscardServerHandler</classname> extends
          &SimpleChannelHandler;, which is an implementation of
          &ChannelUpstreamHandler;.  &SimpleChannelHandler; provides various
          event handler methods that you can override.  For now, it's just
          enough to extend &SimpleChannelHandler; rather than to implement
          handler interfaces.
        </para>
      </callout>
      <callout arearefs="example.discard.co3">
        <para>
          We override the <methodname>messageReceived</methodname> event
          handler method here.  This method is called with a &MessageEvent;,
          which contains the received data, whenever new data is received
          from a client.  In this example, we just ignore the received data
          by doing nothing to implement the DISCARD protocol.
        </para>
      </callout>
      <callout arearefs="example.discard.co4">
        <para>
          <methodname>exceptionCaught</methodname> event handler method is
          called with an &ExceptionEvent; when an exception was raised by
          Netty due to I/O error or by a handler implementation due to the
          exception thrown while processing events.  In most cases, the
          caught exception should be logged and its associated channel
          should be closed here, although the implementation of this method
          can be different depending on what you want to do to deal with an
          exceptional situation.  For example, you might want to send a
          response message with an error code before closing the connection.
        </para>
      </callout>
    </calloutlist>
    <para>
      So far so good.  We have implemented the half of the DISCARD server.
      What's left now is to write the <methodname>main</methodname> method
      which starts the server up with the <classname>DiscardServerHandler</classname>.
    </para>
    <programlisting>package org.jboss.netty.example.discard;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

public class DiscardServer {

    public static void main(String[] args) throws Exception {
        &ChannelFactory; factory =
            new &NioServerSocketChannelFactory;<co id="example.discard2.co1" />(
                    Executors.newCachedThreadPool(),
                    Executors.newCachedThreadPool());

        &ServerBootstrap; bootstrap = new &ServerBootstrap;<co id="example.discard2.co2" />(factory);

        DiscardServerHandler handler = new DiscardServerHandler();
        &ChannelPipeline; pipeline = bootstrap.getPipeline();
        pipeline.addLast("handler", handler);<co id="example.discard2.co3" />

        bootstrap.setOption("child.tcpNoDelay", true);<co id="example.discard2.co4" />
        bootstrap.setOption("child.keepAlive", true);

        bootstrap.bind(new InetSocketAddress(8080));<co id="example.discard2.co5" />
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.discard2.co1">
        <para>
          &ChannelFactory; is a factory which creates and manages &Channel;s
          and its related resources.  It processes all I/O requests and
          performs I/O to generate &ChannelEvent;s.  Netty provides various
          &ChannelFactory; implementations.  We are implementing a server-side
          application in this example, and therefore
          &NioServerSocketChannelFactory; was used.  Another thing to note is
          that it doesn't create I/O threads by itself.  It is supposed to
          acquire threads from the thread pool you specified in the
          constructor, and it gives you more control over how threads should
          be managed in the environment where your application runs, such as
          an application server with a security manager.
        </para>
      </callout>
      <callout arearefs="example.discard2.co2">
        <para>
          &ServerBootstrap; is a helper class that sets up a server. You can
          set up the server by yourself using a &Channel; directly, but it's a
          tedious process and you won't need to do that in most cases.
        </para>
      </callout>
      <callout arearefs="example.discard2.co3">
        <para>
          Here, we add the <classname>DiscardServerHandler</classname> to the
          <emphasis>default</emphasis> &ChannelPipeline;.  Whenever a new
          connection is accepted by the server, a new &ChannelPipeline; will
          be created for a newly accepted &Channel; and all the
          &ChannelHandler;s added here will be added to the new
          &ChannelPipeline;.  It's just like
          <ulink url="http://en.wikipedia.org/wiki/Object_copy">a shallow-copy
          operation</ulink>; all &Channel; and their &ChannelPipeline;s will
          share the same <classname>DiscardServerHandler</classname> instance.
        </para>
      </callout>
      <callout arearefs="example.discard2.co4">
        <para>
          You can also set the parameters which are specific to the &Channel;
          implementation.  We are writing a TCP/IP server, so we are allowed
          to set the socket options such as <literal>tcpNoDelay</literal> and
          <literal>keepAlive</literal>.  Please note that the
          <literal>"child."</literal> prefix was added to all options.  It
          means the options will be applied to the accepted &Channel;s instead
          of the options of the &ServerSocketChannel;.  You could do like the following:
          <programlisting>bootstrap.setOption("reuseAddress", true);</programlisting>
          to set the options of the &ServerSocketChannel;. 
        </para>
      </callout>
      <callout arearefs="example.discard2.co5">
        <para>
          We are ready to go now.  What's left is to bind to the port and to
          start the server.  Here, we bind to the port <literal>8080</literal>
          of all NICs (network interface cards) in the machine.  You are fine
          to call the <methodname>bind</methodname> method as many times as
          you want, with different bind addresses. 
        </para>
      </callout>
    </calloutlist>
    <para>
      Congratulations!  You've just finished your first server on top of Netty.
    </para>
  </section>
  
  <section>
    <title>Looking into the Received Data</title>
    <para>
      Now that we wrote our first server, we need to test if it really works.
      The easiest way to test it is to use the <command>telnet</command>
      command.  For example, you could enter "<command>telnet localhost
      8080</command>" in the command line and type something.
    </para>
    <para>
      However, can we say that the server is working fine?  We can't really
      know that because it's a discard server.  You will not going to get any
      response at all.  To prove it's really working, let's modify the server
      to print what it has received.
    </para>
    <para>
      We already know that &MessageEvent; is generated whenever data is
      received and the <methodname>messageReceived</methodname> handler method
      will be invoked.  Let's put some code into the
      <methodname>messageReceived</methodname> method of the
      <classname>DiscardServerHandler</classname>: 
    </para>
    <programlisting>@Override
public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {
    &ChannelBuffer;<co id="example.discard3.co1"/> buf = (ChannelBuffer) e.getMessage();
    while(buf.readable()) {
        System.out.println((char) buf.readByte(i));
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.discard3.co1">
        <para>
          It is safe to assume the message type in socket transports is always
          &ChannelBuffer;.  &ChannelBuffer; is a fundamental data structure
          which stores a sequence of bytes in Netty.  It's similar to NIO
          <classname>ByteBuffer</classname>, but it's easier to use and more
          flexible.  For example, Netty allows you to create a composite
          &ChannelBuffer; which combines multiple &ChannelBuffer;s reducing
          the number of unnecessary memory copy.
        </para>
        <para>
          Although it resembles to NIO <classname>ByteBuffer</classname> a lot,
          it is highly recommended to refer to the API reference.  Learning how
          to use &ChannelBuffer; correctly is a critical step in using Netty
          without difficulty.  
        </para>
      </callout>
    </calloutlist>
    <para>
      If you run the <command>telnet</command> command again, you will see the
      server prints what has received.
    </para>
    <para>
      The full source code of the discard server is located in the
      <literal>org.jboss.netty.example.discard</literal> package of the
      distribution.
    </para>
  </section>
  <section>
    <title>Writing an Echo Server</title>
    <para>
      So far, we have been consuming data without responding at all.  A server,
      however, is usually supposed to respond to a request.  Let's learn how to
      write a response message to a client by implementing the 
      <ulink url="http://tools.ietf.org/html/rfc862">ECHO</ulink> protocol,
      where any received data is sent back. 
    </para>
    <para>
      The only difference from the discard server we have implemented in the
      previous sections is that it sends the received data back instead of
      printing the received data out to the console.  Therefore, it's just
      enough again to modify the <methodname>messageReceived</methodname>
      method:
    </para>
    <programlisting>@Override
public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {
    &Channel;<co id="example.echo.co1"/> ch = e.getChannel();
    ch.write(e.getMessage());
}</programlisting>
    <calloutlist>
      <callout arearefs="example.echo.co1">
        <para>
          A &ChannelEvent; object has a reference to its associated &Channel;.
          Here, the returned &Channel; represents the connection which received
          the &MessageEvent;.  We can get the &Channel; and call the
          <methodname>write</methodname> method to write something back to
          the remote peer. 
        </para>
      </callout>
    </calloutlist>
    <para>
      If you run the <command>telnet</command> command again, you will see the
      server sends back whatever you have sent to it.
    </para>
    <para>
      The full source code of the echo server is located in the
      <literal>org.jboss.netty.example.echo</literal> package of the
      distribution.
    </para>
  </section>
  
  <section>
    <title>Writing a Time Server</title>
    <para>
      The protocol to implement in this section is the <ulink url="">TIME</ulink>
      protocol.  It is different from the previous examples in that it sends a
      message, which contains a 32-bit integer, without receiving any requests
      and closes the connection once the message is sent.  In this example, you
      will learn how to construct and send a message, and to close the
      connection on completion.
    </para>
    <para>
      Because we are going to ignore any received data but to send a message
      as soon as a connection is established, we can't use the
      <methodname>messageReceived</methodname> method this time.  Instead,
      we should override the <methodname>channelConnected</methodname> method.
      Here's the implementation:
    </para>
    <programlisting>package org.jboss.netty.example.time;

@&ChannelPipelineCoverage;("all")
public class TimeServerHandler extends &SimpleChannelHandler; {

    @Override
    public void channelConnected(&ChannelHandlerContext; ctx, &ChannelStateEvent; e) {<co id="example.time.co1"/>
        &Channel; ch = e.getChannel();
        
        &ChannelBuffer; time = &ChannelBuffers;.buffer(4);<co id="example.time.co2"/>
        time.writeInt(System.currentTimeMillis() / 1000);
        
        &ChannelFuture; f = ch.write(time);<co id="example.time.co3"/>
        
        f.addListener(new &ChannelFutureListener;() {<co id="example.time.co4"/>
            public void operationComplete(&ChannelFuture; f) {
                &Channel; ch = future.getChannel();
                ch.close();
            }
        });
    }

    @Override
    public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.time.co1">
        <para>
          As explained, <methodname>channelConnected</methodname> method will
          be invoked when a connection is established.  Let's write the 32-bit
          integer that represents the current time in seconds here.
        </para>
      </callout>
      <callout arearefs="example.time.co2">
        <para>
          To send a new message, we need to allocate a new buffer which will
          contain the message.  We are going to write a 32-bit integer, and
          therefore we need a &ChannelBuffer; whose capacity is
          <literal>4</literal> bytes.  The &ChannelBuffers; helper class is
          used to allocate a new buffer.  Besides the
          <methodname>buffer</methodname> method, &ChannelBuffers; provides a
          lot of useful methods related with &ChannelBuffer;.  Please refer to
          the API reference.
        </para>
        <para>
          On the other hand, it's a good idea to use static imports for
          &ChannelBuffers;:
          <programlisting>import static org.jboss.netty.buffer.&ChannelBuffers;.*;
...
&ChannelBuffer;  dynamicBuf = dynamicBuffer(256);
&ChannelBuffer; ordinaryBuf = buffer(1024);</programlisting>
        </para>
      </callout>
      <callout arearefs="example.time.co3">
        <para>
          As usual, we write the constructed message.
        </para>
        <para>
          But wait, where's the <methodname>flip</methodname>?  Didn't we used
          to call <methodname>ByteBuffer.flip()</methodname> before sending a
          message in NIO?  &ChannelBuffer; doesn't have such a method because
          it has two pointers; one for read operations and the other for write
          operations.  The writer index increases when you write something to
          a &ChannelBuffer; while the reader index doesn't change.  The reader
          index and the writer index represents where the message starts and
          ends respectively.
        </para>
        <para>
          In contrast, NIO buffer doesn't provide a clean way to figure out
          where the message content starts and ends without calling the
          <methodname>flip</methodname> method.  You will be in trouble when
          you forget to flip the buffer because nothing or incorrect data will
          be sent.  Such an error doesn't happen in Netty because we have
          different pointer for different operation types.  You will find it
          makes your life much easier as you get used to it -- a life without
          flipping out!
        </para>
        <para>
          Another point to note is that the <methodname>write</methodname>
          method returns a &ChannelFuture;.  A &ChannelFuture; represents an
          I/O operation which was not occurred yet.  It means, any requested
          operation might not have been performed yet because all operations
          are asynchronous in Netty.  For example, the following code might
          close the connection even before a message is sent:
        </para>
        <programlisting>&Channel; ch = ...;
ch.write(message);
ch.close();</programlisting>
        <para>
          Therefore, you need to call the <methodname>close</methodname>
          method after the &ChannelFuture;, which was returned by the
          <methodname>write</methodname> method, notifies you when the write
          operation has been done.  Also, <methodname>close</methodname>
          might not close the connection immediately, and it returns a
          &ChannelFuture;.
        </para>
      </callout>
      <callout arearefs="example.time.co4">
        <para>
          How do we get notified when the write request is finished then?
          It's as simple as adding a &ChannelFutureListener; to the returned
          &ChannelFuture;.  Here, we created a new anonymous &ChannelFutureListener;
          which closes the &Channel; when the operation is done.
        </para>
        <para>
          Alternatively, you could simplify the code using a pre-defined
          listener:
          <programlisting>f.addListener(&ChannelFutureListener;.CLOSE);</programlisting>
        </para>
      </callout>
    </calloutlist>
  </section>
  
  <section>
    <title>Writing a Time Client</title>
    <para>
      Unlike DISCARD and ECHO servers, we need a client for the TIME protocol
      because a human can't translate a 32-bit binary data into a date on a
      calendar.  Let's make sure the server works correctly and learn how to
      write a client with Netty.
    </para>
    <para>
      The biggest and only difference between a server and a client in Netty
      is that different &Bootstrap; and &ChannelFactory; are required.  Please
      take a look at the following code:
    </para>
    <programlisting>package org.jboss.netty.example.time;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

public class TimeClient {

    public static void main(String[] args) throws Exception {
        String host = args[0];
        int port = Integer.parseInt(args[1]);

        &ChannelFactory; factory =
            new &NioClientSocketChannelFactory;<co id="example.time2.co1"/>(
                    Executors.newCachedThreadPool(),
                    Executors.newCachedThreadPool());

        &ClientBootstrap; bootstrap = new &ClientBootstrap;<co id="example.time2.co2"/>(factory);

        TimeClientHandler handler = new TimeClientHandler();
        bootstrap.getPipeline().addLast("handler", handler);
        
        bootstrap.setOption("tcpNoDelay"<co id="example.time2.co3"/>, true);
        bootstrap.setOption("keepAlive", true);

        bootstrap.connect<co id="example.time2.co4"/>(new InetSocketAddress(host, port));
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.time2.co1">
        <para>
          &NioClientSocketChannelFactory;, instead of &NioServerSocketChannelFactory;
           was used to create a client-side &Channel;. 
        </para>
      </callout>
      <callout arearefs="example.time2.co2">
        <para>
          &ClientBootstrap; is a client-side counterpart of &ServerBootstrap;.
        </para>
      </callout>
      <callout arearefs="example.time2.co3">
        <para>
          Please note that there's no <literal>"child."</literal> prefix.
          A client-side &SocketChannel; doesn't have a parent.
        </para>
      </callout>
      <callout arearefs="example.time2.co4">
        <para>
          We should call the <methodname>connect</methodname> method instead of
          the <methodname>bind</methodname> method.  
        </para>
      </callout>
    </calloutlist>
    <para>
      As you saw, it's not really different from the server side startup.  What
      about the &ChannelHandler; implementation?  It should receive a 32-bit
      integer from the server, translate it into a human readable format, print
      the translated time, and close the connection:
    </para>
    <programlisting>package org.jboss.netty.example.time;

@&ChannelPipelineCoverage;("all")
public class TimeClientHandler extends &SimpleChannelHandler; {

    @Override
    public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {
        &ChannelBuffer; buf = (&ChannelBuffer;) e.getMessage();
        long currentTimeMillis = buf.readInt() * 1000L;
        System.out.println(new Date(currentTimeMillis()));
        e.getChannel().close();
    }

    @Override
    public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}</programlisting>
    <para>
      It looks very simple and doesn't look any different from the server side
      example.  However, this handler sometimes will refuse to work raising an
      <exceptionname>IndexOutOfBoundsException</exceptionname>.  Let's figure
      out why in the next section.
    </para>
  </section>
  
  <section>
    <title>
      Dealing with Packet Fragmentation and Assembly
    </title>
    <section>
      <title>
        What is Packet Fragmentation and Assembly?
      </title>
      <para>
        In a stream-based transport such as TCP/IP, packets can be fragmented and
        reassembled during transmission even in a LAN environment.  For example,
        let's assume you have received three packets:
      </para>
      <programlisting>+-----+-----+-----+
| ABC | DEF | GHI |
+-----+-----+-----+</programlisting>
      <para>
        because of the packet fragmentation, a server can receive them like the
        following:
      </para>
      <programlisting>+----+-------+---+---+
| AB | CDEFG | H | I |
+----+-------+---+---+</programlisting>
      <para>
        Therefore, a receiving part, regardless it's server-side or client-side,
        should defrag the received packets into one or more meaningful
        <firstterm>frames</firstterm> that could be easily understood by the
        application logic.  In case of the example above, the received packets
        should be defragmented back like the following:
      </para>
      <programlisting>+-----+-----+-----+
| ABC | DEF | GHI |
+-----+-----+-----+</programlisting>
    </section>
    <section>
      <title>
        The First Solution
      </title>
      <para>
        Now let's get back to the TIME client example.  We have the same problem
        here.  A 32-bit integer is a very small amount of data, and it is not
        likely to be fragmented often.  However, the problem is that it
        <emphasis>can</emphasis> be fragmented, and the possibility of
        fragmentation will increase as the traffic goes higher.
      </para>
      <para>
        The simplistic solution is to create an internal cumulative buffer and
        wait until all 4 bytes are received into the internal buffer.  Here's
        the modified <classname>TimeClientHandler</classname> implementation
        that fixes the problem.
      </para>
      <programlisting>package org.jboss.netty.example.time;

import static org.jboss.netty.buffer.&ChannelBuffers;.*;

@&ChannelPipelineCoverage;("one")<co id="example.time3.co1"/>
public class TimeClientHandler extends &SimpleChannelHandler; {

    private final &ChannelBuffer; buf = dynamicBuffer();<co id="example.time3.co2"/>

    @Override
    public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {
        &ChannelBuffer; m = (&ChannelBuffer;) e.getMessage();
        buf.writeBytes(m);<co id="example.time3.co3"/>
        
        if (buf.readableBytes() &gt;= 4) {<co id="example.time3.co4"/>
            long currentTimeMillis = buf.readInt() * 1000L;
            System.out.println(new Date(currentTimeMillis()));
            e.getChannel().close();
        }
    }

    @Override
    public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}</programlisting>
      <calloutlist>
        <callout arearefs="example.time3.co1">
          <para>
            This time, <literal>"one"</literal> was used as the value of the 
            &ChannelPipelineCoverage; annotation.  It's because the new
            <classname>TimeClientHandler</classname> has to maintain the internal
            buffer and therefore cannot serve multiple &Channel;s.  If an
            instance of <classname>TimeClientHandler</classname> is shared by
            multiple &Channel;s (and consequently multiple &ChannelPipeline;s),
            the content of the <varname>buf</varname> will be messed up. 
          </para>
        </callout>
        <callout arearefs="example.time3.co2">
          <para>
            A <firstterm>dynamic buffer</firstterm> is a &ChannelBuffer; which
            increases its capacity on demand.  It's very useful when you don't
            know the length of the message.
          </para>
        </callout>
        <callout arearefs="example.time3.co3">
          <para>
            First, all received data should be cumulated into
            <varname>buf</varname>.
          </para>
        </callout>
        <callout arearefs="example.time3.co4">
          <para>
            And then, the handler must check if <varname>buf</varname> has enough
            data, 4 bytes in this example, and proceed to the actual business
            logic.  Otherwise, Netty will call the
            <methodname>messageReceived</methodname> method again when more
            data arrives, and eventually all 4 bytes will be cumulated.
          </para>
        </callout>
      </calloutlist>
      <para>
        There's another place that needs a fix.  Do you remember that we have
        added a <classname>TimeClientHandler</classname> instance to the
        <emphasis>default</emphasis> &ChannelPipeline; of the &ClientBootstrap;?
        It means one <classname>TimeClientHandler</classname> is going to handle
        multiple &Channel;s and consequently the data will be messed up.  To
        create a new <classname>TimeClientHandler</classname> instance per
        &Channel;, we should implement a &ChannelPipelineFactory;:
      </para>
      <programlisting>package org.jboss.netty.example.time;

public class TimeClientPipelineFactory implements &ChannelPipelineFactory; {

    public &ChannelPipeline; getPipeline() {
        &ChannelPipeline; pipeline = &Channels;.pipeline();
        pipeline.addLast("handler", new TimeClientHandler());
        return pipeline;
    }
}</programlisting>
      <para>
        Now let's replace the following lines of <classname>TimeClient</classname>:
      </para>
      <programlisting>TimeClientHandler handler = new TimeClientHandler();
bootstrap.getPipeline().addLast("handler", handler);</programlisting>
      <para>
        with the following:
      </para>
      <programlisting>bootstrap.getPipelineFactory(new TimeClientPipelineFactory());</programlisting>
      <para>
        It might look somewhat complicated at the first glance, and it is true
        that we don't need to introduce <classname>TimeClientPipelineFactory</classname>
        in this particular case because <classname>TimeClient</classname> creates
        only one connection.
      </para>
      <para>
        However, as your application gets more and more complex, you will end up
        with an implementation of &ChannelPipelineFactory;, which yields much
        more flexibility.
      </para>
    </section>
    <section>
      <title>
        The Second Solution
      </title>
      <para>
        Although the first solution has resolved the problem with the TIME
        client, the modified handler doesn't look that clean.  Imagine a more
        complicated protocol which is composed of multiple fields such as a
        variable length field.  Your &ChannelHandler; implementation will
        become unmaintainable very quickly.
      </para>
      <para>
        As you already might have noticed, you can add more than one
        &ChannelHandler; to a &ChannelPipeline;, and therefore, you can
        split one monolithic &ChannelHandler; into multiple modular ones to
        reduce the complexity of your application.  For example, you could
        split <classname>TimeClientHandler</classname> into two handlers:
        <itemizedlist>
          <listitem>
            <para>
              <classname>TimeDecoder</classname> which deals with the packet
              fragmentation and assembly issue, and
            </para>
          </listitem>
          <listitem>
            <para>
              the initial simple version of <classname>TimeClientHandler</classname>.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        Fortunately, Netty provides an extensible class which enables you to
        write the first one out of the box.
      </para>
      <programlisting>package org.jboss.netty.example.time;

<co id="example.time4.co1"/>
public class TimeDecoder extends &FrameDecoder; {

    @Override
    protected Object decode(
            &ChannelHandlerContext; ctx, &Channel; channel, &ChannelBuffer; buffer)<co id="example.time4.co2"/> {
            
        if (buffer.readableBytes() &lt; 4) {
            return null; <co id="example.time4.co3"/>
        }
        
        return buffer.readBytes(4);<co id="example.time4.co4"/>
    }
}</programlisting>
      <calloutlist>
        <callout arearefs="example.time4.co1">
          <para>
            There's no &ChannelPipelineCoverage; annotation this time because
            &FrameDecoder; is already annotated with <literal>"one"</literal>.
          </para>
        </callout>
        <callout arearefs="example.time4.co2">
          <para>
            &FrameDecoder; calls <methodname>decode</methodname> method with
            an internally maintained cumulative buffer whenever new data is
            received.
          </para>
        </callout>
        <callout arearefs="example.time4.co3">
          <para>
            If <literal>null</literal> is returned, it means there's not 
            enough data yet.  &FrameDecoder; will call again when more data is
            in.
          </para>
        </callout>
        <callout arearefs="example.time4.co3">
          <para>
            If non-<literal>null</literal> is returned, it means the
            <methodname>decode</methodname> method has decoded a message
            successfully.  &FrameDecoder; will discard the read part of its
            internal cumulative buffer.  Please remember that you don't need
            to decode multiple messages.  &FrameDecoder; will keep calling
            the <methodname>decoder</methodname> method until it returns
            <literal>null</literal>. 
          </para>
        </callout>
      </calloutlist>
      <para>
        If you are a adventurous person, you might want to try the
        &ReplayingDecoder; which simplifies the decoder even more.  You will
        need to consult the API reference for more information though.
      </para>
      <programlisting>package org.jboss.netty.example.time;

public class TimeDecoder extends &ReplayingDecoder;&lt;&VoidEnum;&gt; {

    @Override
    protected Object decode(
            &ChannelHandlerContext; ctx, &Channel; channel, &ChannelBuffer; buffer, &VoidEnum; state) {
            
        return buffer.readBytes(4);
    }
}</programlisting>
      <para>
        Additionally, Netty provides out-of-the-box decoders which enables
        you to implement most protocol very easily and helps you avoid from
        ending up with a monolithic unmaintainable handler implementation.
        You might want to take a look into the following packages for more
        detailed examples:
        <itemizedlist>
          <listitem>
            <para>
              <literal>org.jboss.netty.example.factorial</literal> for
              a binary protocol, and
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>org.jboss.netty.example.telnet</literal> for
              a text line-based protocol.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
  </section>
  
  <section>
    <title>
      Speaking in POJO instead of ChannelBuffer
    </title>
    <para>
      All the examples we visited so far used a &ChannelBuffer; as a primary
      data structure of a protocol message.  In this section, we will improve
      the TIME protocol client and server example to use a 
      <ulink url="http://en.wikipedia.org/wiki/POJO">POJO</ulink> instead of a
      &ChannelBuffer;.  
    </para>
    <para>
      The advantage of using a POJO in your &ChannelHandler; is obvious;
      your handler becomes more maintainable and reusable by separating the
      code which extracts information from &ChannelBuffer; out from the
      handler.  In the TIME client and server examples, we read only one
      32-bit integer and it's not a big deal to use &ChannelBuffer; directly.
      However, you will find it is necessary to make the separation as you
      implement a real world protocol.
    </para>
    <para>
      First, let's define a new type called <classname>UnixTime</classname>.
    </para>
    <programlisting>package org.jboss.netty.example.time;

public class UnixTime {
    private final int value;
    
    public UnixTime(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
    
    @Override
    public String toString() {
        return new Date(value * 1000L).toString();
    }
}</programlisting>
    <para>
      We can now revise the <classname>TimeDecoder</classname> to return
      a <classname>UnixTime</classname> instead of a &ChannelBuffer;. 
    </para>
    <programlisting>@Override
protected Object decode(
        &ChannelHandlerContext; ctx, &Channel; channel, &ChannelBuffer; buffer) {
    if (buffer.readableBytes() &lt; 4) {
        return null;
    }

    return new UnixTime(buffer.readInt());<co id="example.time5.co1"/>
}</programlisting>
    <calloutlist>
      <callout arearefs="example.time5.co1">
        <para>
          &FrameDecoder; and &ReplayingDecoder; allow you to return an object
          of any type.  If they were restricted to return only a
          &ChannelBuffer;, we would have to insert another &ChannelHandler;
          which transforms a &ChannelBuffer; into a
          <classname>UnixTime</classname>.
        </para>
      </callout>
    </calloutlist>
    <para>
      With the updated decoder, the <classname>TimeClientHandler</classname>
      doesn't use &ChannelBuffer; anymore:
    </para>
    <programlisting>@Override
public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {
    UnixTime m = (UnixTime) e.getMessage();
    System.out.println(m);
    e.getChannel().close();
}</programlisting>
    <para>
      Much simpler and elegant, right?  The same technique can be applied on
      the server side.  Let's update the
      <classname>TimeServerHandler</classname> first this time:
    </para>
    <programlisting>@Override
public void channelConnected(&ChannelHandlerContext; ctx, &ChannelStateEvent; e) {
    UnixTime time = new UnixTime(System.currentTimeMillis() / 1000);
    &ChannelFuture; f = e.getChannel().write(time);
    f.addListener(&ChannelFutureListener;.CLOSE);
}</programlisting>
    <para>
      Now, the only missing piece is the &ChannelHandler; which translates a
      <classname>UnixTime</classname> back into a &ChannelBuffer;.  It's much
      simpler than writing a decoder because there's no need to deal with 
      packet fragmentation and assembly when encoding a message.
    </para>
    <programlisting>package org.jboss.netty.example.time;
    
import static org.jboss.netty.buffer.&ChannelBuffers;.*;

@&ChannelPipelineCoverage;("all")<co id="example.time6.co1"/>
public class TimeEncoder implements &ChannelDownstreamHandler; {<co id="example.time6.co2"/>

    public void handleDownstream(&ChannelHandlerContext; ctx, &ChannelEvent; e) {
        if (!(e instanceof &MessageEvent;)) {
            ctx.sendDownstream(e);<co id="example.time6.co3"/>
            return;
        }

        UnixTime time = (UnixTime) ((&MessageEvent;) e).getMessage();
        
        &ChannelBuffer; buf = buffer(4);
        buf.writeInt(time.getValue());
        
        &Channels;.write(ctx, e.getChannel(), e.getFuture(), buf);<co id="example.time6.co4"/>
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.time6.co1">
        <para>
          The &ChannelPipelineCoverage; value of an encoder is usually
          <literal>"all"</literal> because an encoder is stateless in most
          cases. 
        </para>
      </callout>
      <callout arearefs="example.time6.co2">
        <para>
          An encoder implements a &ChannelDownstreamHandler; to intercept a
          write request.  &ChannelDownstreamHandler; is a sub-type of
          &ChannelHandler; that is used to intercept the downstream events,
          which flows in the opposite direction of the &ChannelEvent;s we have
          been processing so far.  Please refer to the API reference to learn
          more about the difference between a upstream event and a downstream
          event.
        </para>
      </callout>
      <callout arearefs="example.time6.co3">
        <para>
          &MessageEvent; is not the only event that a &ChannelDownstreamHandler;
          intercepts.  You need to forward the events of a unknown type so that
          the other &ChannelDownstreamHandler;s or I/O thread processes them.
        </para>
      </callout>
      <callout arearefs="example.time6.co4">
        <para>
          Once done with transforming a POJO into a &ChannelBuffer;, you should
          forward the new buffer to the previous &ChannelDownstreamHandler; in
          the &ChannelPipeline;.  &Channels; provides various helper methods
          which generates and sends a &ChannelEvent;.  In this example,
          &Channels;<literal>.write(...)</literal> method creates a new
          &MessageEvent; and sends it to the previous &ChannelDownstreamHandler;
          in the &ChannelPipeline;.
        </para>
        <para>
          On the other hand, it's a good idea to use static imports for
          &Channels;:
          <programlisting>import static org.jboss.netty.channel.&Channels;.*;
...
&ChannelPipeline; pipeline = pipeline();
write(ctx, e.getChannel(), e.getFuture(), buf);
fireChannelDisconnected(ctx, e.getChannel());</programlisting>
        </para>
      </callout>
    </calloutlist>
    <para>
      At this point, you might wonder why you didn't have to forward a
      &ChannelEvent; to the next &ChannelUpstreamHandler; in the
      &ChannelPipeline; when we write the decoders.  Actually, it had been
      done behind the scene by &FrameDecoder; and &ReplayingDecoder;.
      The <classname>TimeDecoder</classname> would look like the following if
      it didn't extend neither &FrameDecoder; nor &SimpleChannelHandler;.   
    </para>
    <programlisting>package org.jboss.netty.example.time;

import static org.jboss.netty.buffer.&ChannelBuffers;.*;
import static org.jboss.netty.channel.&Channels;.*;

@&ChannelPipelineCoverage;("one")
public class TimeDecoder implements &ChannelUpstreamHandler; {

    private final &ChannelBuffer; buf = dynamicBuffer();

    public void handleUpstream(&ChannelHandlerContext; ctx, &ChannelEvent; e) {
        if (!(e instanceof &MessageEvent;)) {
            ctx.sendUpstream(e);
            return;
        }

        &ChannelBuffer; m = (&ChannelBuffer;) ((&MessageEvent;) e).getMessage();
        buf.writeBytes(m);
        
        while (buf.readableBytes() &gt;= 4) {
            UnixTime time = new UnixTime(buf.readInt());
            fireMessageReceived(ctx, time);
        }
        
        buf.discardReadBytes();
    }
}</programlisting>
    <para>
      The last task left is to insert a <classname>TimeEncoder</classname>
      into the &ChannelPipeline; on the server side, and it's left as a
      trivial exercise.
    </para>
  </section>
  
  <section>
    <title>
      Summary
    </title>
    <para>
      In this section, we had a quick tour of Netty so that you can start to
      write a network application on top of Netty right away.  I believe you
      still have a lot of questions about various topics, and they will be
      covered in the upcoming chapters and the revised version of this chapter.
      Also, please don't forget that <ulink url="&Community;">the Netty project
      community</ulink> is always here to help you.
    </para>
  </section>
</chapter>
