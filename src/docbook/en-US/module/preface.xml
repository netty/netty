<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Copyright 2009 Red Hat, Inc.
 *
 * Red Hat licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
-->
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD; 
]>
<preface id="preface">
  <title>Preface</title>

  <section>
    <title>The Problem</title>
    <para>
      Nowadays we use general purpose applications or libraries to communicate
      with each other.  For example, we often use an HTTP client library to
      retrieve information from a web server and to invoke a remote procedure
      call via web services.
    </para>
    <para>
      However, a general purpose protocol or its implementation sometimes 
      does not scale very well.  It is like we don't use a general purpose
      HTTP server to exchange huge files, e-mail messages, and near-realtime
      messages such as financial information and multiplayer game data.
      What's required is a highly optimized protocol implementation which is
      dedicated to a special purpose.  For example, you might want to
      implement an HTTP server which is optimized for AJAX-based chat
      application, media streaming, or large file transfer.  You could even
      want to design and implement a whole new protocol which is precisely
      tailored to your need.
    </para>
    <para>
      Another inevitable case is when you have to deal with a legacy
      proprietary protocol to ensure the interoperability with an old system.
      What matters in this case is how quickly we can implement that protocol
      while not sacrificing the stability and performance of the resulting
      application.
    </para>
  </section>
  
  <section>
    <title>The Solution</title>
    <para>
      <firstterm><ulink url="&Home;">The Netty project</ulink></firstterm> is
      an effort to provide an asynchronous event-driven network application
      framework and tooling for the rapid development of maintainable
      high-performance &middot; high-scalability protocol servers and clients.
    </para>
    <para>
      In other words, Netty is a NIO client server framework which enables
      quick and easy development of network applications such as protocol
      servers and clients.  It greatly simplifies and streamlines network
      programming such as TCP and UDP socket server development.
    </para>
    <para>
      'Quick and easy' does not mean that a resulting application will suffer
      from a maintainability or a performance issue.  Netty has been designed
      carefully with the experiences earned from the implementation of a lot
      of protocols such as FTP, SMTP, HTTP, and various binary and text-based
      legacy protocols.  As a result, Netty has succeeded to find a way to
      achieve ease of development, performance, stability, and flexibility
      without a compromise.
    </para>
    <para>
      Some users might already have found other network application
      framework that claims to have the same advantage, and you might want
      to ask what makes Netty so different from them.  The answer is the
      philosophy where it is built on.  Netty is designed to give you the most
      comfortable experience both in terms of the API and the implementation
      from the day one.  It is not something tangible but you will realize that
      this philosophy will make your life much easier as you read this guide
      and play with Netty. 
    </para>
  </section>
</preface>
