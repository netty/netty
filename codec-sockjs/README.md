## SockJS Netty Support
This project provided support for [SockJSProtocol](http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html).

Prior to Netty 4, Carl Bystr√∂m wrote a [version for Netty 3.x](https://github.com/cgbystrom/sockjs-netty) which most 
of this version is based on.

### Disclaminer
Currently the haproxy test in the [SockJSProtocol](http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html) does
not pass.  
The issue here is that when HAProxy tries to send an WebSocket Hixie 76 upgrade reqeust it need to be able
to send the request headers, and receive the response before it sends the actualy nouce.  
The test, ```test_haproxy```, and I'm assuming HAProxy itself does not set a _Content-Length_ header. HttpObjectDecoder in
Netty does a check while decoding to see if a _Content-Lenght_ header exists, which is our case it does not. It then 
does a second check to see if the request is a WebSocket request, and correctly detects that this is. Netty will then
set the _Content-Lenght_ header to 8 for Hixie 76. This causes the request to not be passed along as there is not actual
body in this request.  
Setting the _Content-Length_ to 0 allows the test_haproxy test to pass successfully. I'm not sure
how to fix this. I don't think that there should really be a case where the body of a Hixie 74 upgrade request does not
have the nounce in the body of the request. So perhaps a workaround specific to sockjs should be put inplace.


### Testing using sockjs-protocol
Apart from the unit/functional tests an external test suite is provided for SockJS. 
First, start the SockJS server:

    mvn exec:java

Next, follow the instructions for [sockjs-protocol](https://github.com/sockjs/sockjs-protocol) to run the tests.

The equivalent of the above python test suite can be found in ```io.netty.handler.codec.sockjs.protocol.SockJSProtocolTest.java```.

### Protocol
The SockJS client API is very similar to the WebSocket API which is intentional. The idea is to hide the transport 
details from the end user and gracefully fallback through the supported transport protocols to find one that is 
supported by the browser and the server.

The client API looks like this:

    var sock = new SockJS('http://localhost:port/prefix');
    
    sock.onopen = function() {
      console.log('open');
    };
    
    sock.onmessage = function(e) {
      console.log('message', e.data);
    };
    
    sock.onclose = function() {
      console.log('close');
    };
   
The _prefix_, or name if you will, is the name of the SockJS service. A single SockJS server can handle many SockJS 
services.


#### Info request
The first thing that happens in the protocol setup is that the url _prefix/info_ is called which will return a JSON 
similar to this:

    {"websocket":true,"cookie_needed":true,"origins":["*:*"],"entropy":2971480297}
    
This information is retreived before the client starts the session and is used to determine the server side support 
features as well as way to measure the roundtrip time between the client and the server.  
Each SockJS service can configure its own setting for the information above, and additionaly configure things like the 
session timeout and the heartbeat frequency. For more information see the ```Configuration``` section below.

#### Greeting request
All services also have a greeting url which is just the simple prefix/name of the SockJS service, which can be accessed 
using the url _http://localhost:port/echo_:  

    Welcome to SockJS!


#### Session handling
Session handling is required for all protocols except WebSocket. This is to allow interactions that behave like WebSockets 
where we open a connection, work, and later close it. But the other transports are using HTTP and will do a 
request/response style of interaction. For these protocols we provide a session handling that works with SockJS frames 
(OpenFrame, HeartbeatFrame, MessageFrame, and CloseFrame). 

The session is always initiated by the client and the client can specify a url that looks like this:  

    http://localhost:port/prefix/serverId/sessionId/transport_protocol
    
__prefix__  
This is the name of the SockJS service that will perform some business logic. A SockJS server can host any number of 
SockJS services. 

__serverId__  
This is three digit number chosen by the client. The main use of this path parameter is for sticky session to make it 
easier to configure load balancers.

__sessionId__  
This is a random string that must be unique for every session. This is also generated by the client.

__transport_protcol__  
This is the type of transport that should be used for the SockJS Protocol.  

### Frame Protocol

#### Open Frame
When the server establishes a new session an open frame must be sent to the client.  

    o
    
#### Heartbeat Frame
The server must send a heartbeat frame now and again (configurable) to keep the connection from breaking. The SockJS 
protocol says that this is typcially 25 seconds which is the default.

    h
    
#### Message Frame
A message is the payload that is destined for the SockJS service. This is business logic related data. The structure is 
an array of JSON:  

    a["message"]


#### Close Frame
If the client ask for data on a closed connection a close frame is sent in response. It can have a status code and a 
status message:   

    c[3000,"Go away!"]

### SockJSService
This is the actual business logic that will send and receive messages.
The interface looks like this:

    public interface SockJSService {
        void onOpen(SessionContext session);
        void onMessage(String message) throws Exception;
        void onClose();
        Config config();
    }
    
__onOpen__  
Will be called when new session is created and opened. The _SessionContext_ instance can be stored and used to send 
messages over the session and also to close the session.

__onMessage__  
Will be called when a message is sent over the SockJS protocol to this service.

__onClose__  
Will be called when the session is closed. 

__config__  
Retreives this services configuration. Every service can configure if websockets are enabled, if cookies are reqired, 
and also properties related to the session, like session timeout etc. See the _Configuration_ section below for more details.

### SockJSServiceFactory
A SockJSService is created by server side. There might be cases where one would like to have an instance created for 
every session, or just one instance that is shared. To accomodate this a SockJSServiceFactory implementation is what 
is passed into the SockJSChannelInitializer :

    /**
     * A factory for creating {@link SockJSService} instances.
     */
    public interface SockJSServiceFactory {

        /**
         * Creates a new instance, or reuse and existing instance, of the service.
         * Allows for either creating new instances for every session of to use
         * a single instance, whatever is appropriate for the use case.
         *
         * @return {@link SockJSService} the service instance.
         */
        SockJSService create();

        /**
         * The {@link Config} for the session itself.
         *
         * @return Config the configuration for the session.
         */
        Config config();

}

### Config
Each service can configure it's own session properties:

    final Config config = Config.prefix("/echo")
                     .cookiesNeeded()
                     .websocketEnabled()
                     .heartbeatInterval(25000)
                     .sessionTimeout(5000)
                     .maxStreamingBytesSize()
                     .build();
                     
__prefix__  
The name of the SockJS service.                     
                     
__cookiesNeeded__  
Determines if a JSESSIONID cookie will be set. This is used by some load balancers to enable session stickyness.

__disableWebsocket__  
Will disable WebSocket support. By default WebSocket support is enabled.

__heartbeatInterval__  
The interval in millisecond that the server will send a heartbeat frame.

__maxStreamingBytesSize__  
The max number of types that a streaming transport protocol should allow to be returned before closing the connection, 
forcing the client to reconnect. This is done so that the responseText in the XHR Object will not grow and be come an 
issue for the client. Instead, by forcing a reconnect the client will create a new XHR object and this can be see as a
 form of garbage collection.
 
### Transport protocols
                     
#### XHR Polling
When using a polling connection there is no open connection between the client and the server. Instead the client will 
issue a new request for polling and sending data to the SockJS service.   

An example of an xhr-polling request can look like this:  

    http://localhost/echo/server1/session1/xhr
    
This is a poll request and if this is the first request with this session id, _session1_ above, a new session will be 
created on the server. The response of this, if successful, will be a 200 with a SockJS open frame.  
If a session already exists for the session, then any messages that have been queued up will be sent to the client. This 
is how to receive messages from the server by polling.  

But we also need to be able to send messages to the SockJSService which can look like this:

    http://localhost/echo/server1/session1/xhr_send
    
This HTTP request should contain a SockJS message frame which will be an array of JSON encoded objects. This JSON array 
will be decoded on the server side and each one will be delivered to the target SockJSServer by invoking its _onMessage_ method.
A successful send will returns a status of _NO_CONTENT_.

#### JSONP Polling
Jsonp polling is very similar to xhr-polling in how the connections are handled.

An example of an xhr-polling request can look like this:  

    http://localhost/echo/server1/session1/jsonp?c=callback
    
The same session handling semantics are the play as for xhr-polling. You'll notice that in this case we have specified a 
query parameter named _c_, for callback, which expects the function name that will be used on the client side. What 
differs from the xhr-polling transport is the format data is sent back to the to the client when making a poll request.
Instead of returning the data directly in the body of the response, the data will be wrapped in a function:

    'callback("h");\r\n'

We also need to be able to send messages to the SockJSService which can look like this:

    http://localhost/echo/server1/session1/jsonp_send
    
A successful send will returns a status of _OK_.

#### XHR Streaming
With xhr streaming the requirement is that HTTP 1.1 is used. This is because support for HTTP chunking is required so 
that the server can hold a persistent connection open to the browser and send chunks of data. 

An example of an xhr-streaming request can look like this:  

    http://localhost/echo/server1/session1/xhr_streaming
    
A successful response will look like this:

    HTTP/1.1 200 OK
    Transfer-Encoding: chunked
    Content-Type: application/javascript; charset=UTF-8
    Set-Cookie: JSESSIONID=dummy; path=/
    Cache-Control: no-store, no-cache, must-revalidate, max-age=0
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Credentials: true
    
The HTTP header _Transfer-Encoding_ is set to _chunked_ which will cause the browser to keep the connection open and 
not close it until it gets the last chunk (just a chunk which has a length of zero).  

The data received by the client will get appended to _responseText_ field in the XHR object. Letting this grow and grow 
is not a good idea, therefore the server has a configurable _maxStreamingByteSize_ setting which when that amount of 
bytes have been sent a _last chunk_ will be sent to close the connection. This will force the client to make a new 
request and will clear out the _responseText_ field, a form of garbage collection if you will.

To send data you use the now familiar _xhr_send_:

    http://localhost/echo/server1/session1/xhr_send
    
The _sessionId_ should be the same as the one used with the _xhr_streaming_ request.

#### EventSource
EventSource is like xhr-streaming a streaming protocol where a persistent connection is created on the server to the 
browser. This connection will remain open until the server closes it. 

An example of an xhr-streaming request can look like this:  
    http://localhost/echo/server1/session1/eventsource

A successful response will look like this:

    HTTP/1.1 200 OK
    Transfer-Encoding: chunked
    Content-Type: text/event-stream; charset=UTF-8
    Set-Cookie: JSESSIONID=dummy; path=/
    Cache-Control: no-store, no-cache, must-revalidate, max-age=0
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Credentials: true
    
Much like the XHR streaming transport the EventSource transport uses the same ``maxStreamingByteSize``` to control the 
build of data on the client side. This is reported as required by SockJS as they have found bugs in browser:
* https://bugs.webkit.org/show_bug.cgi?id=61863
* http://code.google.com/p/chromium/issues/detail?id=68160

#### HtmlFile
Is also a streaming transport where the the content should be placed inside an iframe. The src of the iframe will be the 
url to the service and should include a callback function:

    http://localhost/echo/server1/session1/htmlfile?c=callback
    
The response of this call will be an normal HTTP response of 200 (OK) is successful but the connection will remain open 
as this is a streaming transport and the server can write to the connection when updates are available. 
The first chuck written by the server will be a header for the iframe:

    <!doctype html>
        <html><head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        </head><body><h2>Don't panic!</h2>
            <script>
                document.domain = document.domain;
                var c = parent.callback;
                c.start();
                function p(d) {
                    c.message(d);
                };
                window.onload = function() {
                  c.stop();
                };
                // padding of white space here
                // ...
          </script>

The updated chunks will looks like this:

    <script>
      p('o');
    </script>
    
The message above is for a SockJS open frame and this string will be passed to the _p_ function, which will then delegate 
to the callback specified as the _c_ query parameter in the url to the SockJS server.  
So for every update on the server side a new script element like this will be appended and evaluated. For this reason we 
need to have some sort of max limit so that this does not grow out of proportion and cause troubles on the client side. 
Again, _maxStreamingByteSize_ is used for just this purpose. 

#### WebSocket
WebSockets come in two forms in SockJS, one is where you connect using the uri pattern that we have been using so far:

    https://host:port/echo/serverId/sessionId/websocket
    
This should be used by any SockJS clients. But it is also possible that non SockJS clients would like to interact with 
the SockJS server but use _raw_ websockets. This is done but connecting using the uri:

    wss://host:port/echo/websocket
    
This is referred to as _raw_ websockets as the normal SockJS protocol is not in effect. This is intended for non-browser 
clients that might connect with a WebSocket library. 

The initial request to the server will perform the HTTP upgrade requet to web sockets and from there on the client and 
the server maintain a bi-directional connection on which they can both send and receive data. When the server is sent 
data it will extract the messages and the SockJS service will be invoked. The WebSocketTransport will also handle SockJS 
frames that are to be written to the client.
